// apps/web/src/store/channel.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import type { ConnectionState, Request } from '../types';
import type { SourcesEnabled } from '../types';
import type { PartyMessage } from '../types/party';
import { deserializeRequest, deserializeRequests } from '../types/party';
import {
  broadcastAdd,
  broadcastUpdate,
  broadcastToggleDone,
  broadcastReorder,
  broadcastDelete,
  broadcastSetAll,
  broadcastSources,
  broadcastIrcStatus,
} from '../services/party';

// ============ REQUESTS STORE ============

interface RequestsStore {
  requests: Request[];
  partyConnected: boolean;
  isOwner: boolean;
  add: (req: Request) => void;
  update: (id: number, updates: Partial<Request>) => void;
  toggleDone: (id: number) => void;
  setAll: (requests: Request[]) => void;
  reorder: (fromId: number, toId: number) => void;
  deleteRequest: (id: number) => void;
  setPartyConnected: (connected: boolean) => void;
  setIsOwner: (isOwner: boolean) => void;
  handlePartyMessage: (msg: PartyMessage) => void;
}

export type RequestsStoreApi = ReturnType<typeof createRequestsStore>;

export function createRequestsStore(channel: string, getSourcesState: () => SourcesStore) {
  return create<RequestsStore>()(
    persist(
      (set, get) => ({
        requests: [],
        partyConnected: false,
        isOwner: false,

        add: (req) => {
          const { partyConnected, isOwner, requests: existingRequests } = get();
          if (existingRequests.some(r => r.id === req.id)) return;

          set((s) => {
            const { sortMode, priority } = getSourcesState();
            if (sortMode === 'fifo') {
              return { requests: [...s.requests, req] };
            }
            const requests = [...s.requests];
            const reqPri = priority.indexOf(req.source);
            let insertIdx = requests.length;
            for (let i = 0; i < requests.length; i++) {
              if (requests[i].done) continue;
              const iPri = priority.indexOf(requests[i].source);
              if (iPri > reqPri || (iPri === reqPri && requests[i].timestamp > req.timestamp)) {
                insertIdx = i;
                break;
              }
            }
            requests.splice(insertIdx, 0, req);
            return { requests };
          });

          if (partyConnected && isOwner) {
            broadcastAdd(req);
          }
        },

        update: (id, updates) => {
          const { partyConnected, isOwner } = get();
          set((s) => ({
            requests: s.requests.map((r) => (r.id === id ? { ...r, ...updates } : r)),
          }));
          if (partyConnected && isOwner) {
            broadcastUpdate(id, updates);
          }
        },

        toggleDone: (id) => {
          const { partyConnected, isOwner } = get();
          set((s) => ({
            requests: s.requests.map((r) => (r.id === id ? { ...r, done: !r.done } : r)),
          }));
          if (partyConnected && isOwner) {
            broadcastToggleDone(id);
          }
        },

        setAll: (requests) => {
          const { partyConnected, isOwner } = get();
          set({ requests });
          if (partyConnected && isOwner) {
            broadcastSetAll(requests);
          }
        },

        reorder: (fromId, toId) => {
          const { partyConnected, isOwner } = get();
          set((s) => {
            const requests = [...s.requests];
            const fromIdx = requests.findIndex(r => r.id === fromId);
            const toIdx = requests.findIndex(r => r.id === toId);
            if (fromIdx === -1 || toIdx === -1) return s;
            const [moved] = requests.splice(fromIdx, 1);
            requests.splice(toIdx, 0, moved);
            return { requests };
          });
          if (partyConnected && isOwner) {
            broadcastReorder(fromId, toId);
          }
        },

        deleteRequest: (id) => {
          const { partyConnected, isOwner } = get();
          set((s) => ({
            requests: s.requests.filter((r) => r.id !== id),
          }));
          if (partyConnected && isOwner) {
            broadcastDelete(id);
          }
        },

        setPartyConnected: (connected) => set({ partyConnected: connected }),
        setIsOwner: (isOwner) => set({ isOwner }),

        handlePartyMessage: (msg) => {
          switch (msg.type) {
            case 'sync-full': {
              const serverRequests = deserializeRequests(msg.requests);
              const localRequests = get().requests;
              const { isOwner, partyConnected } = get();

              // Owner seeds empty server from localStorage
              if (serverRequests.length === 0 && localRequests.length > 0 && isOwner && partyConnected) {
                const sources = getSourcesState();
                broadcastSetAll(localRequests);
                broadcastSources(sources);
              } else {
                set({ requests: serverRequests });
              }
              // Clean up localStorage - PartyKit is source of truth
              localStorage.removeItem(`dbd-requests-${channel}`);
              localStorage.removeItem(`dbd-sources-${channel}`);
              break;
            }
            case 'add-request': {
              const req = deserializeRequest(msg.request);
              set((s) => {
                if (s.requests.some(r => r.id === req.id)) return s;
                const { sortMode, priority } = getSourcesState();
                if (sortMode === 'fifo') {
                  return { requests: [...s.requests, req] };
                }
                const requests = [...s.requests];
                const reqPri = priority.indexOf(req.source);
                let insertIdx = requests.length;
                for (let i = 0; i < requests.length; i++) {
                  if (requests[i].done) continue;
                  const iPri = priority.indexOf(requests[i].source);
                  if (iPri > reqPri || (iPri === reqPri && requests[i].timestamp > req.timestamp)) {
                    insertIdx = i;
                    break;
                  }
                }
                requests.splice(insertIdx, 0, req);
                return { requests };
              });
              break;
            }
            case 'update-request':
              set((s) => ({
                requests: s.requests.map((r) =>
                  r.id === msg.id
                    ? { ...r, ...msg.updates, timestamp: msg.updates.timestamp ? new Date(msg.updates.timestamp) : r.timestamp }
                    : r
                ),
              }));
              break;
            case 'toggle-done':
              set((s) => ({
                requests: s.requests.map((r) => (r.id === msg.id ? { ...r, done: !r.done } : r)),
              }));
              break;
            case 'reorder':
              set((s) => {
                const requests = [...s.requests];
                const fromIdx = requests.findIndex(r => r.id === msg.fromId);
                const toIdx = requests.findIndex(r => r.id === msg.toId);
                if (fromIdx === -1 || toIdx === -1) return s;
                const [moved] = requests.splice(fromIdx, 1);
                requests.splice(toIdx, 0, moved);
                return { requests };
              });
              break;
            case 'delete-request':
              set((s) => ({
                requests: s.requests.filter((r) => r.id !== msg.id),
              }));
              break;
            case 'set-all':
              set({ requests: deserializeRequests(msg.requests) });
              break;
          }
        },
      }),
      {
        name: `dbd-requests-${channel}`,
        partialize: (state) => ({ requests: state.requests }),
        // Read-only storage: load from localStorage for seeding, but don't persist
        // PartyKit is the source of truth after initial sync
        storage: {
          getItem: (name) => {
            const str = localStorage.getItem(name);
            if (!str) return null;
            const parsed = JSON.parse(str);
            return {
              state: {
                ...parsed.state,
                requests: (parsed.state.requests || []).map((r: any) => ({
                  ...r,
                  timestamp: new Date(r.timestamp),
                })),
              },
            };
          },
          setItem: () => { },
          removeItem: () => { },
        },
      }
    )
  );
}

// ============ SOURCES STORE ============

type SourceType = 'donation' | 'resub' | 'chat' | 'manual';
type SortMode = 'priority' | 'fifo';

interface SourcesStore {
  enabled: SourcesEnabled;
  chatCommand: string;
  chatTiers: number[];
  priority: SourceType[];
  sortMode: SortMode;
  minDonation: number;
  setEnabled: (enabled: SourcesEnabled) => void;
  toggleSource: (source: keyof SourcesEnabled) => void;
  setChatCommand: (cmd: string) => void;
  setChatTiers: (tiers: number[]) => void;
  setPriority: (priority: SourceType[]) => void;
  setSortMode: (mode: SortMode) => void;
  setMinDonation: (min: number) => void;
  handlePartyMessage: (msg: PartyMessage) => void;
}

export type SourcesStoreApi = ReturnType<typeof createSourcesStore>;

export const SOURCES_DEFAULTS = {
  enabled: {
    donation: true,
    chat: true,
    resub: false,
    manual: true,
  },
  chatCommand: '!fila',
  chatTiers: [2, 3],
  priority: ['donation', 'chat', 'resub', 'manual'] as SourceType[],
  sortMode: 'fifo' as SortMode,
  minDonation: 5,
};


export function createSourcesStore(
  channel: string,
  getContext: () => { partyConnected: boolean; isOwner: boolean }
) {
  const maybeBroadcast = (get: () => SourcesStore) => {
    const { partyConnected, isOwner } = getContext();
    if (partyConnected && isOwner) {
      const sources = get();
      broadcastSources(sources);
    }
  };

  return create<SourcesStore>()(
    persist(
      (set, get) => ({
        enabled: SOURCES_DEFAULTS.enabled,
        chatCommand: SOURCES_DEFAULTS.chatCommand,
        chatTiers: SOURCES_DEFAULTS.chatTiers,
        priority: SOURCES_DEFAULTS.priority,
        sortMode: SOURCES_DEFAULTS.sortMode,
        minDonation: SOURCES_DEFAULTS.minDonation,
        setEnabled: (enabled) => {
          set({ enabled });
          maybeBroadcast(get);
        },
        toggleSource: (source) => {
          set((s) => ({ enabled: { ...s.enabled, [source]: !s.enabled[source] } }));
          maybeBroadcast(get);
        },
        setChatCommand: (chatCommand) => {
          set({ chatCommand });
          maybeBroadcast(get);
        },
        setChatTiers: (chatTiers) => {
          set({ chatTiers });
          maybeBroadcast(get);
        },
        setPriority: (priority) => {
          set({ priority });
          maybeBroadcast(get);
        },
        setSortMode: (sortMode) => {
          set({ sortMode });
          maybeBroadcast(get);
        },
        setMinDonation: (minDonation) => {
          set({ minDonation });
          maybeBroadcast(get);
        },
        handlePartyMessage: (msg) => {
          if (msg.type === 'sync-full' || msg.type === 'update-sources') {
            const sources = msg.sources;
            set({
              enabled: sources.enabled,
              chatCommand: sources.chatCommand,
              chatTiers: sources.chatTiers,
              priority: sources.priority,
              sortMode: sources.sortMode,
              minDonation: sources.minDonation,
            });
          }
        },
      }),
      {
        name: `dbd-sources-${channel}`,
        // Read-only: load from localStorage for seeding, PartyKit is source of truth
        storage: {
          getItem: (name) => {
            const str = localStorage.getItem(name);
            return str ? JSON.parse(str) : null;
          },
          setItem: () => { },
          removeItem: () => { },
        },
      }
    )
  );
}

// ============ CHANNEL INFO STORE ============

type ChannelStatus = 'offline' | 'online' | 'live';

interface ChannelOwner {
  login: string;
  displayName: string;
  avatar: string;
}

interface ChannelInfoStore {
  status: ChannelStatus;
  owner: ChannelOwner | null;
  localIrcConnectionState: ConnectionState;
  localPartyConnectionState: ConnectionState;
  setIrcConnectionState: (state: ConnectionState) => void;
  setPartyConnectionState: (state: ConnectionState) => void;
  handlePartyMessage: (msg: PartyMessage) => void;
}

export type ChannelInfoStoreApi = ReturnType<typeof createChannelInfoStore>;

export function createChannelInfoStore(
  getContext: () => { partyConnected: boolean; isOwner: boolean; sources: SourcesStore }
) {
  return create<ChannelInfoStore>()((set, get) => ({
    status: 'offline',
    owner: null,
    localIrcConnectionState: 'disconnected',
    localPartyConnectionState: 'disconnected',
    setIrcConnectionState: (state) => {
      set({ localIrcConnectionState: state });
      const { isOwner } = getContext();
      if (isOwner) {
        broadcastIrcStatus(state === 'connected');
      }
    },
    setPartyConnectionState: (state) => {
      set({ localPartyConnectionState: state });
    },
    handlePartyMessage: (msg) => {
      if (msg.type === 'sync-full' || msg.type === 'update-channel') {
        set({
          status: msg.channel.status,
          owner: msg.channel.owner,
        });
      }
    },
  }));
}

// ============ CHANNEL STORES ============

export interface ChannelStores {
  useRequests: RequestsStoreApi;
  useSources: SourcesStoreApi;
  useChannelInfo: ChannelInfoStoreApi;
}

// Given a room name, initialize all the stores for that room
export function createRoomStores(channel: string): ChannelStores {
  const key = channel.toLowerCase();
  let useSources: SourcesStoreApi;
  let useChannelInfo: ChannelInfoStoreApi;

  const useRequests = createRequestsStore(key, () => useSources.getState());

  useSources = createSourcesStore(key, () => {
    const { partyConnected, isOwner } = useRequests.getState();
    return { partyConnected, isOwner };
  });

  useChannelInfo = createChannelInfoStore(() => {
    const { partyConnected, isOwner } = useRequests.getState();
    return { partyConnected, isOwner, sources: useSources.getState() };
  });

  return { useRequests, useSources, useChannelInfo };
}
